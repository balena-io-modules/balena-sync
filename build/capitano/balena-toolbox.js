// Generated by CoffeeScript 1.12.7

/*
Copyright 2016 Balena

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

   http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
 */
module.exports = {
  signature: 'push [deviceIp]',
  description: 'Push your changes to a container on local balenaOS device ',
  help: 'Warning: \'balena local push\' requires an openssh-compatible client and \'rsync\' to\nbe correctly installed in your shell environment. For more information (including\nWindows support) please check the README here: https://github.com/balena-io/balena-cli\n\nUse this command to push your local changes to a container on a LAN-accessible balenaOS device on the fly.\n\nIf `Dockerfile` or any file in the \'build-triggers\' list is changed, a new container will be built and run on your device.\nIf not, changes will simply be synced with `rsync` into the application container.\n\nAfter every \'balena local push\' the updated settings will be saved in\n\'<source>/.balena-sync.yml\' and will be used in later invocations. You can\nalso change any option by editing \'.balena-sync.yml\' directly.\n\nHere is an example \'.balena-sync.yml\' :\n\n	$ cat $PWD/.balena-sync.yml\n	destination: \'/usr/src/app\'\n	before: \'echo Hello\'\n	after: \'echo Done\'\n	ignore:\n		- .git\n		- node_modules/\n\nCommand line options have precedence over the ones saved in \'.balena-sync.yml\'.\n\nIf \'.gitignore\' is found in the source directory then all explicitly listed files will be\nexcluded when using rsync to update the container. You can choose to change this default behavior with the\n\'--skip-gitignore\' option.\n\nExamples:\n\n	$ balena local push\n	$ balena local push --app-name test-server --build-triggers package.json,requirements.txt\n	$ balena local push --force-build\n	$ balena local push --force-build --skip-logs\n	$ balena local push --ignore lib/\n	$ balena local push --verbose false\n	$ balena local push 192.168.2.10 --source . --destination /usr/src/app\n	$ balena local push 192.168.2.10 -s /home/user/myBalenaProject -d /usr/src/app --before \'echo Hello\' --after \'echo Done\'',
  primary: true,
  options: [
    {
      signature: 'source',
      parameter: 'path',
      description: 'root of project directory to push',
      alias: 's'
    }, {
      signature: 'destination',
      parameter: 'path',
      description: 'destination path on device container',
      alias: 'd'
    }, {
      signature: 'ignore',
      parameter: 'paths',
      description: "comma delimited paths to ignore when syncing with 'rsync'",
      alias: 'i'
    }, {
      signature: 'skip-gitignore',
      boolean: true,
      description: 'do not parse excluded/included files from .gitignore'
    }, {
      signature: 'before',
      parameter: 'command',
      description: 'execute a command before pushing',
      alias: 'b'
    }, {
      signature: 'after',
      parameter: 'command',
      description: 'execute a command after pushing',
      alias: 'a'
    }, {
      signature: 'progress',
      boolean: true,
      description: 'show progress',
      alias: 'p'
    }, {
      signature: 'skip-logs',
      boolean: true,
      description: 'do not stream logs after push'
    }, {
      signature: 'verbose',
      boolean: true,
      description: 'increase verbosity',
      alias: 'v'
    }, {
      signature: 'app-name',
      parameter: 'name',
      description: 'application name - may contain lowercase characters, digits and one or more dashes. It may not start or end with a dash.',
      alias: 'n'
    }, {
      signature: 'build-triggers',
      parameter: 'files',
      description: 'comma delimited file list that will trigger a container rebuild if changed',
      alias: 'r'
    }, {
      signature: 'force-build',
      boolean: true,
      description: 'force a container build and run',
      alias: 'f'
    }, {
      signature: 'env',
      parameter: 'env',
      description: "environment variable (e.g. --env 'ENV=value'). Multiple --env parameters are supported.",
      alias: 'e'
    }
  ],
  action: function(params, options, done) {
    var DockerUtils, Promise, _, build, chalk, checkTriggers, configYml, createBuildTriggerHashes, fileExists, parseOptions, path, ref, ref1, ref2, runtimeOptions, selectLocalBalenaOsDevice, selectSyncDestination, sync, yamlConfig;
    path = require('path');
    Promise = require('bluebird');
    _ = require('lodash');
    chalk = require('chalk');
    yamlConfig = require('../yaml-config');
    parseOptions = require('./parse-options');
    DockerUtils = require('../docker-utils');
    ref = require('../forms'), selectSyncDestination = ref.selectSyncDestination, selectLocalBalenaOsDevice = ref.selectLocalBalenaOsDevice;
    fileExists = require('../utils').fileExists;
    sync = require('../sync')('local-balena-os-device').sync;
    ref1 = require('../build-trigger'), createBuildTriggerHashes = ref1.createBuildTriggerHashes, checkTriggers = ref1.checkTriggers;

    /**
    		 * @summary Start image-building 'balena local push' process
    		 * @function build
    		 *
    		 * @param {Object} options - options
    		 * @param {String} options.appName - Application image (i.e. image & container name)
    		 * @param {String} options.deviceIp - Device ip or host
    		 * @param {String} [options.baseDir=process.cwd()] - Project base directory that also containers Dockerfile
    		 *
    		 * @returns {} - Exits process with 0 on success or 1 otherwise
    		 * @throws Exception on error
    		 *
    		 * @example
    		 * build(appName: 'test', deviceIp: '192.168.1.1')
     */
    build = function(arg) {
      var appName, baseDir, deviceIp, docker, env, ref2, ref3, ref4;
      ref2 = arg != null ? arg : {}, appName = ref2.appName, deviceIp = ref2.deviceIp, env = (ref3 = ref2.env) != null ? ref3 : [], baseDir = (ref4 = ref2.baseDir) != null ? ref4 : process.cwd();
      if (appName == null) {
        throw new Error("Missing application name for 'balena push'");
      }
      if (deviceIp == null) {
        throw new Error("Missing device ip/host for 'balena push'");
      }
      docker = new DockerUtils(deviceIp);
      console.log(chalk.yellow.bold('* Building..'));
      console.log("- Stopping and removing any previous '" + appName + "' container");
      return Promise.all([
        docker.stopContainer(appName).then(function() {
          return docker.removeContainer(appName);
        }), docker.inspectImage(appName)["catch"](function(err) {
          var statusCode;
          statusCode = '' + err.statusCode;
          if (statusCode === '404') {
            return null;
          }
          throw err;
        }), docker.getAllImages().map(function(image) {
          return image.Id;
        })
      ]).spread(function(__, oldImageInfo, existingImageIds) {
        console.log('- Uploading build context & starting build...');
        return docker.buildImage({
          baseDir: baseDir,
          name: appName,
          outStream: process.stdout,
          cacheFrom: existingImageIds
        }).then(function() {
          return docker.inspectImage(appName);
        }).then(function(newImageInfo) {
          if ((oldImageInfo != null) && oldImageInfo.Id !== newImageInfo.Id) {
            console.log("- Cleaning up previous image of '" + appName + "'");
            return docker.removeImage(oldImageInfo.Id);
          }
        });
      }).then(function() {
        console.log("- Creating '" + appName + "' container");
        return docker.createContainer(appName, {
          env: env
        });
      }).then(function() {
        console.log("- Starting '" + appName + "' container");
        return docker.startContainer(appName);
      });
    };
    ref2 = parseOptions(options, params), runtimeOptions = ref2.runtimeOptions, configYml = ref2.configYml;
    if (!fileExists(path.join(runtimeOptions.baseDir, 'Dockerfile'))) {
      if (fileExists(path.join(runtimeOptions.baseDir, 'Dockerfile.template'))) {
        throw new Error('Dockerfile.template files are not yet supported by local push. \n\nAs a workaround, you can rename your \'Dockerfile.template\' to \'Dockerfile\', and replace all %%TEMPLATE%% strings with the appropriate values, as documented in https://balena.io/docs/learn/develop/dockerfile/#dockerfile-templates. For example \'%%RESIN_MACHINE_NAME%%\' would become \'raspberrypi3\' on a Raspberry Pi 3 device. \n\nSubscribe to https://github.com/balena-io/balena-cli/issues/604 for updates.');
      } else {
        throw new Error("No Dockerfile found in the project directory: " + runtimeOptions.baseDir);
      }
    }
    return Promise["try"](function() {
      var ref3;
      return (ref3 = runtimeOptions.deviceIp) != null ? ref3 : selectLocalBalenaOsDevice();
    }).then(function(deviceIp) {
      var appName, configYmlBuildTriggers, docker, ref3;
      appName = (ref3 = runtimeOptions.appName) != null ? ref3 : 'local-app';
      runtimeOptions.deviceIp = deviceIp;
      runtimeOptions.appName = appName;
      configYml['local_balenaos']['app-name'] = appName;
      docker = new DockerUtils(deviceIp);
      configYmlBuildTriggers = configYml['local_balenaos']['build-triggers'];
      return Promise.reduce([
        _.isEmpty(configYmlBuildTriggers) || !_.isEmpty(options['build-triggers']), runtimeOptions.forceBuild, checkTriggers(configYmlBuildTriggers), docker.checkForExistingImage(appName).then(function(exists) {
          return !exists;
        }), docker.checkForRunningContainer(appName).then(function(isRunning) {
          return !isRunning;
        })
      ], function(shouldRebuild, result, index) {
        return shouldRebuild || result;
      }, false).then(function(shouldRebuild) {
        if (shouldRebuild) {
          return createBuildTriggerHashes({
            baseDir: runtimeOptions.baseDir,
            files: runtimeOptions.buildTriggerFiles
          }).then(function(buildTriggerHashes) {
            configYml['local_balenaos']['build-triggers'] = buildTriggerHashes;
            configYml['local_balenaos']['environment'] = runtimeOptions.env;
            yamlConfig.save(configYml, runtimeOptions.baseDir);
            return build(_.pick(runtimeOptions, ['baseDir', 'deviceIp', 'appName', 'env']));
          });
        } else {
          console.log(chalk.yellow.bold('* Syncing..'));
          return selectSyncDestination(runtimeOptions.destination).then(function(destination) {
            var notNil;
            runtimeOptions.destination = destination;
            notNil = function(val) {
              return !_.isNil(val);
            };
            yamlConfig.save(_.assign({}, configYml, _(runtimeOptions).pick(['destination', 'ignore', 'before', 'after']).pickBy(notNil).value()), runtimeOptions.baseDir);
            return sync(_.pick(runtimeOptions, ['baseDir', 'deviceIp', 'appName', 'destination', 'before', 'after', 'progress', 'verbose', 'skipGitignore', 'ignore']));
          });
        }
      }).then(function() {
        return console.log(chalk.green.bold('\nPush completed successfully!'));
      })["catch"](function(err) {
        console.log(chalk.red.bold('Push failed.', err, err.stack));
        return process.exit(1);
      }).then(function() {
        if (runtimeOptions.skipLogs === true) {
          return process.exit(0);
        }
        console.log(chalk.yellow.bold('* Streaming application logs..'));
        return docker.followContainerLogs(appName)["catch"](function(err) {
          console.log('[Info] Could not stream logs from container', err);
          return process.exit(0);
        });
      });
    }).nodeify(done);
  }
};
